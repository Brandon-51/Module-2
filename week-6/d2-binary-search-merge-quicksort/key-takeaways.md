# Be able to:

- describe binary search, merge and quick sort and be able to identify each based on descriptions of behavior
- identify best and worse case complexity of each
- use the built in array.sort() method and be able to create compare functions to use with .sort()


-quick sort: algorithm divides the array around a pivot, then sorts the left and right sides
time complexity: O(n log n) (average)
space complexity: O(1) in place, O(n log n) (out of place)

-merge sort: divide and conquer algorithm that divides the unsorted array into subarrays each containing one element, and repeatedly merges them to make new sorted subarrays until there is only one array.
time complexity: O(n log n)
space complexity: O(1) (in place), O(n log n) (out of place)